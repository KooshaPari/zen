from __future__ import annotations

import hashlib
import os
import re
import uuid
from dataclasses import asdict
from typing import Any

from .base import EditOperation, EditPlan, EditProvider


class BuiltinFastPatchProvider(EditProvider):
    """Simple, safe, instruction-driven edits.

    Supports three op types:
    - replace: find/replace within file (optional count)
    - insert: insert content before/after first anchor match
    - write: overwrite file with content

    Does not do semantic code transforms. Intended as a fallback or for
    deterministic edits generated by an upstream model/agent.
    """

    name = "builtin_fastpatch"

    def plan_edit(
        self,
        *,
        instructions: str | None = None,
        operations: list[dict] | None = None,
        context: dict[str, Any] | None = None,
    ) -> EditPlan:
        ops: list[EditOperation] = []
        for op in operations or []:
            ops.append(EditOperation(**op))
        plan_id = str(uuid.uuid4())
        return EditPlan(id=plan_id, instructions=instructions, operations=ops, provider=self.name, metadata={})

    def _read(self, path: str) -> str:
        with open(path, encoding="utf-8") as f:
            return f.read()

    def _write(self, path: str, content: str) -> None:
        # Create directory if needed
        os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)

    def _apply_op(self, src: str, op: EditOperation) -> tuple[str, dict[str, Any]]:
        info: dict[str, Any] = {"type": op.type}
        if op.type == "replace":
            find = op.find or ""
            replace = op.replace or ""
            count = 0 if op.count is None else int(op.count)
            if count and count < 0:
                count = 0
            new, n = re.subn(re.escape(find), replace, src, count=count or 0)
            info.update({"replacements": n})
            return new, info
        elif op.type == "insert":
            anchor = op.anchor or ""
            pos = (op.position or "after").lower()
            idx = src.find(anchor) if anchor else -1
            if idx == -1:
                return src, {"skipped": True, "reason": "anchor_not_found"}
            insert_at = idx if pos == "before" else idx + len(anchor)
            content = op.content or ""
            new = src[:insert_at] + content + src[insert_at:]
            return new, {"inserted": len(content)}
        elif op.type == "write":
            return op.content or "", {"overwritten": True, "bytes": len((op.content or "").encode("utf-8"))}
        else:
            return src, {"skipped": True, "reason": "unknown_op"}

    def _diff(self, before: str, after: str) -> str:
        import difflib

        before_lines = before.splitlines(keepends=True)
        after_lines = after.splitlines(keepends=True)
        diff = difflib.unified_diff(before_lines, after_lines, fromfile="a", tofile="b")
        return "".join(diff)

    def _digest(self, content: str) -> str:
        return hashlib.sha256(content.encode("utf-8")).hexdigest()[:16]

    def dry_run(self, plan: EditPlan) -> dict:
        results: dict[str, Any] = {"plan_id": plan.id, "provider": self.name, "files": []}
        by_file: dict[str, list[EditOperation]] = {}
        for op in plan.operations:
            by_file.setdefault(op.filepath, []).append(op)

        for path, ops in by_file.items():
            try:
                before = self._read(path) if os.path.exists(path) else ""
                after = before
                op_infos: list[dict[str, Any]] = []
                for op in ops:
                    after, info = self._apply_op(after, op)
                    info.update({"op": asdict(op)})
                    op_infos.append(info)
                results["files"].append({
                    "path": path,
                    "exists": os.path.exists(path),
                    "before_digest": self._digest(before),
                    "after_digest": self._digest(after),
                    "diff_preview": self._diff(before, after),
                    "ops": op_infos,
                })
            except Exception as e:
                results.setdefault("errors", []).append({"path": path, "error": str(e)})

        return results

    def apply(self, plan: EditPlan) -> dict:
        preview = self.dry_run(plan)
        changed = 0
        for f in preview.get("files", []):
            try:
                # Recompute final content based on ops on disk content to avoid drift
                path = f["path"]
                before = self._read(path) if os.path.exists(path) else ""
                after = before
                for op in [EditOperation(**entry["op"]) for entry in f.get("ops", [])]:
                    after, _ = self._apply_op(after, op)
                if after != before:
                    self._write(path, after)
                    changed += 1
            except Exception as e:
                preview.setdefault("errors", []).append({"path": f.get("path"), "error": str(e)})

        preview["applied"] = True
        preview["files_changed"] = changed
        return preview

